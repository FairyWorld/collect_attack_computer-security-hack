# 1.9 漏洞发掘概述 

## 环境搭建  
《黑客之道 漏洞发掘的艺术》有随书的CD，下载地址为 https://www.epubit.com/bookDetails?id=UB720969fa1e61d 


- [通用的漏洞发掘技术](#通用的漏洞发掘技术)
- [缓冲区溢出](#缓冲区溢出)
- [尝试使用BASH](#尝试使用BASH)
- [其他内存段中的溢出](#其他内存段中的溢出)
- [格式化字符串](#格式化字符串)



## 通用的漏洞发掘技术  

“程序漏洞发掘”是黑客攻击的主题。  
程序由一组复杂规则组成，这些规则遵守一定的执行流程，最终告诉计算机应当做什么。
所谓发掘一个程序的漏洞，就是
使计算机按照你的意图做事的一种巧妙方法，即使当前运行的程序想阻止，你照样心想事
成。程序实际上只能完全按照设计意图运行，因此安全漏洞实际上是程序设计上或者程序
运行环境中的缺陷或疏忽。为发现这些漏洞并编写补丁来修补这些漏洞，需要具有创造性
思维。有些漏洞是明显的编程错误造成的，但有些漏洞比较隐蔽，因此，黑客需要设法在
名个不同位置运用更复杂的漏洞发掘技术来发起攻击。  

有些漏洞，开发者很难及时发现，而其他编程人员在事后能够轻松发现。大多数程序漏洞发掘与内存破坏有关，包括常见的诸如缓冲区溢出的漏洞发掘技术，以及不常见的诸如格式化字符串的漏洞发掘技术。  

使用这些技术的最终目的是控制目标程序的执行流程，以欺骗程序使其运行一段偷偷植入内存的恶意代码，这成为“执行任意代码”，得名的原因是黑客可根据自己的意愿命令程序做几乎任何事。  

## 缓冲区溢出  

在计算机问世之初，缓沖区滥出漏洞就已经存在，并一直延续到今天。大多数 Intemet
蠕虫程序使用绶冲区滥出漏洞来传播，甚至 Interet Explorer 中的一些零日 VML 漏洞也是
由于缓冲区溢出造成的。  

C 语言是一种高级编程语言，但假定编程人员负责数据的完整性。如果将这种责任转
移给编译器，那么编译器会检查每个变量的完整性，最后得到二进制代码将耗费相当长的
时间。而且这也会使程序员失去一个重要的控制层，使C语言更加复杂。  

C语言的简单性确实增加了编程人员的控制能力，提高了最终程序的效率，但若程序
员不够谨慎，这种简单性会引发程序缓冲区溢出和内存泄漏之类的漏洞。这意味着，一旦
给某个变量分配存储空间，将没有内置的安全机制来确保该变量的容量能适应己分配的存
储空间。如果程序员要将 10 个字节的数据存入只能容纳 8 个字节空间的缓冲区中，虽然这
种操作是允许的，但这样一来，由于多出的2个字节数据会溢出，存储在己分配的存储空
间之外，重写已分配存储空间之后的数据，从而导致缓冲区超限 (bufrer overrun）或缓冲
区溢出 (buffer overflow），程序很可能会崩溃。如果重写的是一段关键数据，程序必定崩
溃，下面是示例代码:  

我们用C语言来写一个简单的模拟用户登录的例子，在该例子中，让用户输入的字符和用户密码相比较，如果密码正确就输出Welcome!，如果输入的密码错误就输出Sorry, your password is wrong.  
```c
//  main.c
#include <stdio.h>
#include <string.h>
int main(int argc, const char * argv[]) {

    char passsword[8] = "secret", input[8];
    while (1) {
        printf("Enter your password:");
        gets(input);
        if (strcmp(input, passsword) == 0) {
            printf("Welcome!\n");
            break;
        }else {
            printf("Sorry,your password is wrong.\n");
        }
    }
    return 0;
}
```

模拟输入:
```shell
$ gcc main.c -o main 
$ ./main 
$ warning : this program uses gets(), which is unsafe.
$ Enter your password:12345678ok
$ Sorry,your password is wrong.
$ Enter your password:ok
$ Welcome!
```

从操作中可以看到，第一次输入的内容是12345678ok，第二次输入的内容是ok，结果根据程序的判断，结果却是正确的。究竟问什么会出现这种现象呢？从C语言的表面，我们看不出任何的逻辑错误可以造成这种结果。我们再以一个简单的例子来说说函数调用的过程。

> 32为系统与64位系统有差异，64位系统 `passsword[8]` 分配了16个字节，需要输入`1234567890123456ok`  

目前已32位系统为例讲解:  
从汇编实现可以看出，`passsword`变量与`input`变量内存是连续的，在没有输入参数之前内存如下  

| 变量名 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 
| ----- | - | - | - | - | - | - | - | - |
| passsword | \0 | t | c| e | r | c | e | s |
| input | - | - | - | - | - | - | - | - |  

> x86 栈内存分配是从高地址到低地址，而且是小端  

输入`12345678ok`后，内存布局为:  
| 变量名 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 
| ----- | - | - | - | - | - | - | - | - |
| passsword | \0 | t | c| e | r | \0 | k | o |
| input | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |  

这时`passsword`变量的值变为`ok`了，也就是密码变成`ok`  

## 尝试使用BASH


## 其他内存段中的溢出


## 格式化字符串